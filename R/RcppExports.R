# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Compute one Fisher scoring step for GLMs
#' 
#' @description
#' Internal function to compute one Fisher scoring step for GLMs.
#' It constitutes the building block of the AIRWLS algorithm for the
#' estimation of GMF models.
#' 
#' @param beta current value of the regression coefficients to be updated
#' @param y response vector
#' @param X design matrix
#' @param familyname model family name
#' @param linkname link function name
#' @param offset vector of constants to be added to the linear predictor
#' @param penalty penalty parameter of a ridge-type penalty
#' 
#' @keywords internal
cpp.airwls.glmstep <- function(beta, y, X, familyname, linkname, offset, penalty) {
    .Call(`_sgdGMF_cpp_airwls_glmstep`, beta, y, X, familyname, linkname, offset, penalty)
}

#' @title Fisher scoring algorithm for GLMs
#' 
#' @description
#' Internal function implementing the Fisher scoring algorithms for the
#' estimation of GLMs. It is used in the AIRWLS algorithm for the 
#' estimation of GMF models.
#' 
#' @param beta initial value of the regression coefficients to be estimated
#' @param y response vector
#' @param X design matrix
#' @param familyname model family name
#' @param linkname link function name
#' @param offset vector of constants to be added to the linear predictor
#' @param penalty penalty parameter of a ridge-type penalty
#' @param nsteps number of iterations
#' @param stepsize stepsize parameter of the Fisher scoring algorithm
#' @param print if \code{TRUE}, print the algorithm history
#' 
#' @keywords internal
cpp.airwls.glmfit <- function(beta, y, X, familyname, linkname, offset, penalty, nsteps = 100L, stepsize = 0.1, print = FALSE) {
    .Call(`_sgdGMF_cpp_airwls_glmfit`, beta, y, X, familyname, linkname, offset, penalty, nsteps, stepsize, print)
}

#' @title AIRWLS update for GMF models
#' 
#' @description
#' Internal function implementing one step of AIRWLS for the
#' estimation of GMF models. 
#' 
#' @param beta initial value of the regression coefficients to be estimated
#' @param Y response vector
#' @param X design matrix
#' @param familyname model family name
#' @param linkname link function name
#' @param idx index identifying the parameters to be updated in \code{beta}
#' @param offset vector of constants to be added to the linear predictor
#' @param penalty penalty parameter of a ridge-type penalty
#' @param transp if \code{TRUE}, transpose the data
#' @param nsteps number of iterations
#' @param stepsize stepsize parameter of the Fisher scoring algorithm
#' @param print if \code{TRUE}, print the algorithm history
#' @param parallel if \code{TRUE}, run the updates in parallel using \code{openMP}
#' @param nthreads number of threads to be run in parallel (only if \code{parallel=TRUE})
#' 
#' @keywords internal
cpp.airwls.update <- function(beta, Y, X, familyname, linkname, idx, offset, penalty, transp = FALSE, nsteps = 100L, stepsize = 0.1, print = FALSE, parallel = FALSE, nthreads = 1L) {
    .Call(`_sgdGMF_cpp_airwls_update`, beta, Y, X, familyname, linkname, idx, offset, penalty, transp, nsteps, stepsize, print, parallel, nthreads)
}

#' @title Fit a GMF model using the AIRWLS algorithm
#'
#' @description Fit a GMF model using the AIRWLS algorithm
#'
#' @param Y matrix of responses (\eqn{n \times m})
#' @param X matrix of row fixed effects (\eqn{n \times p})
#' @param B initial row-effect matrix (\eqn{n \times p})
#' @param A initial column-effect matrix (\eqn{n \times q})
#' @param Z matrix of column fixed effects (\eqn{m \times q})
#' @param U initial factor matrix (\eqn{n \times d})
#' @param V initial loading matrix (\eqn{m \times d})
#' @param familyname a \code{glm} model family name
#' @param linkname a \code{glm} link function name
#' @param ncomp rank of the latent matrix factorization
#' @param lambda penalization parameters
#' @param maxiter maximum number of iterations
#' @param nsteps number of inner Fisher scoring iterations
#' @param stepsize stepsize of the inner Fisher scoring algorithm
#' @param eps shrinkage factor for extreme predictions
#' @param nafill how often the missing values are updated
#' @param tol tolerance threshold for the stopping criterion
#' @param damping diagonal dumping factor for the Hessian matrix
#' @param verbose if \code{TRUE}, print the optimization status
#' @param frequency how often the optimization status is printed
#' @param parallel if \code{TRUE}, allows for parallel computing
#' @param nthreads number of cores to be used in parallel
#'
#' @keywords internal
cpp.fit.airwls <- function(Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter = 500L, nsteps = 1L, stepsize = 0.1, eps = 1e-08, nafill = 1L, tol = 1e-05, damping = 1e-03, verbose = TRUE, frequency = 10L, parallel = FALSE, nthreads = 1L) {
    .Call(`_sgdGMF_cpp_fit_airwls`, Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter, nsteps, stepsize, eps, nafill, tol, damping, verbose, frequency, parallel, nthreads)
}

#' @title Fit a GMF model using the diagonal quasi-Newton algorithm
#'
#' @description Fit a GMF model using the diagonal quasi-Newton algorithm
#'
#' @param Y matrix of responses (\eqn{n \times m})
#' @param X matrix of row fixed effects (\eqn{n \times p})
#' @param B initial row-effect matrix (\eqn{n \times p})
#' @param A initial column-effect matrix (\eqn{n \times q})
#' @param Z matrix of column fixed effects (\eqn{m \times q})
#' @param U initial factor matrix (\eqn{n \times d})
#' @param V initial loading matrix (\eqn{m \times d})
#' @param familyname a \code{glm} model family name
#' @param linkname a \code{glm} link function name
#' @param ncomp rank of the latent matrix factorization
#' @param lambda penalization parameters
#' @param maxiter maximum number of iterations
#' @param stepsize stepsize of the quasi-Newton update
#' @param eps shrinkage factor for extreme predictions
#' @param nafill how often the missing values are updated
#' @param tol tolerance threshold for the stopping criterion
#' @param damping diagonal dumping factor for the Hessian matrix
#' @param verbose if \code{TRUE}, print the optimization status
#' @param frequency how often the optimization status is printed
#' @param parallel if \code{TRUE}, allows for parallel computing
#' @param nthreads number of cores to be used in parallel
#'
#' @keywords internal
cpp.fit.newton <- function(Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter = 500L, stepsize = 0.1, eps = 1e-08, nafill = 1L, tol = 1e-05, damping = 1e-03, verbose = TRUE, frequency = 10L, parallel = FALSE, nthreads = 1L) {
    .Call(`_sgdGMF_cpp_fit_newton`, Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter, stepsize, eps, nafill, tol, damping, verbose, frequency, parallel, nthreads)
}

#' @title Fit a GMF model using the adaptive SGD with coordinate-wise minibatch subsampling algorithm
#'
#' @description Fit a GMF model using the adaptive SGD with coordinate-wise minibatch subsampling algorithm
#'
#' @param Y matrix of responses (\eqn{n \times m})
#' @param X matrix of row fixed effects (\eqn{n \times p})
#' @param B initial row-effect matrix (\eqn{n \times p})
#' @param A initial column-effect matrix (\eqn{n \times q})
#' @param Z matrix of column fixed effects (\eqn{m \times q})
#' @param U initial factor matrix (\eqn{n \times d})
#' @param V initial loading matrix (\eqn{m \times d})
#' @param familyname a \code{glm} model family name
#' @param linkname a \code{glm} link function name
#' @param ncomp rank of the latent matrix factorization
#' @param lambda penalization parameters
#' @param maxiter maximum number of iterations
#' @param eps shrinkage factor for extreme predictions
#' @param nafill how often the missing values are updated
#' @param tol tolerance threshold for the stopping criterion
#' @param size1 row-minibatch dimension
#' @param size2 column-minibatch dimension
#' @param burn burn-in period in which the learning late is not decreased
#' @param rate0 initial learning rate
#' @param decay decay rate of the learning rate
#' @param damping diagonal dumping factor for the Hessian matrix
#' @param rate1 decay rate of the first moment estimate of the gradient
#' @param rate2 decay rate of the second moment estimate of the gradient
#' @param parallel if \code{TRUE}, allows for parallel computing
#' @param nthreads number of cores to be used in parallel
#' @param verbose if \code{TRUE}, print the optimization status
#' @param frequency how often the optimization status is printed
#' @param progress if \code{TRUE}, print an progress bar
#' 
#' @keywords internal
cpp.fit.csgd <- function(Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter = 1000L, eps = 0.01, nafill = 10L, tol = 1e-08, size1 = 100L, size2 = 100L, burn = 0.75, rate0 = 0.01, decay = 0.01, damping = 1e-03, rate1 = 0.95, rate2 = 0.99, parallel = FALSE, nthreads = 1L, verbose = TRUE, frequency = 250L, progress = FALSE) {
    .Call(`_sgdGMF_cpp_fit_csgd`, Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter, eps, nafill, tol, size1, size2, burn, rate0, decay, damping, rate1, rate2, parallel, nthreads, verbose, frequency, progress)
}

#' @title Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling
#'
#' @description Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling
#'
#' @param Y matrix of responses (\eqn{n \times m})
#' @param X matrix of row fixed effects (\eqn{n \times p})
#' @param B initial row-effect matrix (\eqn{n \times p})
#' @param A initial column-effect matrix (\eqn{n \times q})
#' @param Z matrix of column fixed effects (\eqn{m \times q})
#' @param U initial factor matrix (\eqn{n \times d})
#' @param V initial loading matrix (\eqn{m \times d})
#' @param familyname a \code{glm} model family name
#' @param linkname a \code{glm} link function name
#' @param ncomp rank of the latent matrix factorization
#' @param lambda penalization parameters
#' @param maxiter maximum number of iterations
#' @param eps shrinkage factor for extreme predictions
#' @param nafill how often the missing values are updated
#' @param tol tolerance threshold for the stopping criterion
#' @param size1 row-minibatch dimension
#' @param size2 column-minibatch dimension
#' @param burn burn-in period in which the learning late is not decreased
#' @param rate0 initial learning rate
#' @param decay decay rate of the learning rate
#' @param damping diagonal dumping factor for the Hessian matrix
#' @param rate1 decay rate of the first moment estimate of the gradient
#' @param rate2 decay rate of the second moment estimate of the gradient
#' @param parallel if \code{TRUE}, allows for parallel computing
#' @param nthreads number of cores to be used in parallel
#' @param verbose if \code{TRUE}, print the optimization status
#' @param frequency how often the optimization status is printed
#' @param progress if \code{TRUE}, print an progress bar
#' 
#' @keywords internal
cpp.fit.bsgd <- function(Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter = 1000L, eps = 0.01, nafill = 10L, tol = 1e-08, size1 = 100L, size2 = 100L, burn = 0.75, rate0 = 0.01, decay = 0.01, damping = 1e-03, rate1 = 0.95, rate2 = 0.99, parallel = FALSE, nthreads = 1L, verbose = TRUE, frequency = 250L, progress = FALSE) {
    .Call(`_sgdGMF_cpp_fit_bsgd`, Y, X, B, A, Z, U, V, familyname, linkname, ncomp, lambda, maxiter, eps, nafill, tol, size1, size2, burn, rate0, decay, damping, rate1, rate2, parallel, nthreads, verbose, frequency, progress)
}

#' @keywords internal
cpp.deviance <- function(y, mu, familyname) {
    .Call(`_sgdGMF_cpp_deviance`, y, mu, familyname)
}

#' @keywords internal
cpp.penalty <- function(u, p) {
    .Call(`_sgdGMF_cpp_penalty`, u, p)
}

#' @keywords internal
cpp.family.gaussian.variance <- function(mu) {
    .Call(`_sgdGMF_cpp_gaussian_variance`, mu)
}

#' @keywords internal
cpp.family.gaussian.initialize <- function(y) {
    .Call(`_sgdGMF_cpp_gaussian_initialize`, y)
}

#' @keywords internal
cpp.family.gaussian.devresid <- function(y, mu) {
    .Call(`_sgdGMF_cpp_gaussian_devresid`, y, mu)
}

#' @keywords internal
cpp.family.binomial.variance <- function(mu) {
    .Call(`_sgdGMF_cpp_binomial_variance`, mu)
}

#' @keywords internal
cpp.family.binomial.initialize <- function(y) {
    .Call(`_sgdGMF_cpp_binomial_initialize`, y)
}

#' @keywords internal
cpp.family.binomial.devresid <- function(y, mu) {
    .Call(`_sgdGMF_cpp_binomial_devresid`, y, mu)
}

#' @keywords internal
cpp.family.poisson.variance <- function(mu) {
    .Call(`_sgdGMF_cpp_poisson_variance`, mu)
}

#' @keywords internal
cpp.family.poisson.initialize <- function(y) {
    .Call(`_sgdGMF_cpp_poisson_initialize`, y)
}

#' @keywords internal
cpp.family.poisson.devresid <- function(y, mu) {
    .Call(`_sgdGMF_cpp_poisson_devresid`, y, mu)
}

#' @keywords internal
cpp.family.gamma.variance <- function(mu) {
    .Call(`_sgdGMF_cpp_gamma_variance`, mu)
}

#' @keywords internal
cpp.family.gamma.initialize <- function(y) {
    .Call(`_sgdGMF_cpp_gamma_initialize`, y)
}

#' @keywords internal
cpp.family.gamma.devresid <- function(y, mu) {
    .Call(`_sgdGMF_cpp_gamma_devresid`, y, mu)
}

#' @keywords internal
cpp.family.negbinom.variance <- function(mu) {
    .Call(`_sgdGMF_cpp_negbinom_variance`, mu)
}

#' @keywords internal
cpp.family.negbinom.initialize <- function(y) {
    .Call(`_sgdGMF_cpp_negbinom_initialize`, y)
}

#' @keywords internal
cpp.family.negbinom.devresid <- function(y, mu) {
    .Call(`_sgdGMF_cpp_negbinom_devresid`, y, mu)
}

#' @keywords internal
cpp.link.identity.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_identity_linkfun`, mu)
}

#' @keywords internal
cpp.link.identity.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_identity_linkinv`, eta)
}

#' @keywords internal
cpp.link.identity.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_identity_mueta`, eta)
}

#' @keywords internal
cpp.link.logit.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_logit_linkfun`, mu)
}

#' @keywords internal
cpp.link.logit.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_logit_linkinv`, eta)
}

#' @keywords internal
cpp.link.logit.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_logit_mueta`, eta)
}

#' @keywords internal
cpp.link.probit.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_probit_linkfun`, mu)
}

#' @keywords internal
cpp.link.probit.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_probit_linkinv`, eta)
}

#' @keywords internal
cpp.link.probit.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_probit_mueta`, eta)
}

#' @keywords internal
cpp.link.cauchy.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_cauchy_linkfun`, mu)
}

#' @keywords internal
cpp.link.cauchy.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_cauchy_linkinv`, eta)
}

#' @keywords internal
cpp.link.cauchy.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_cauchy_mueta`, eta)
}

#' @keywords internal
cpp.link.cloglog.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_cloglog_linkfun`, mu)
}

#' @keywords internal
cpp.link.cloglog.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_cloglog_linkinv`, eta)
}

#' @keywords internal
cpp.link.cloglog.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_cloglog_mueta`, eta)
}

#' @keywords internal
cpp.link.log.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_log_linkfun`, mu)
}

#' @keywords internal
cpp.link.log.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_log_linkinv`, eta)
}

#' @keywords internal
cpp.link.log.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_log_mueta`, eta)
}

#' @keywords internal
cpp.link.inverse.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_inverse_linkfun`, mu)
}

#' @keywords internal
cpp.link.inverse.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_inverse_linkinv`, eta)
}

#' @keywords internal
cpp.link.inverse.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_inverse_mueta`, eta)
}

#' @keywords internal
cpp.link.sqrt.linkfun <- function(mu) {
    .Call(`_sgdGMF_cpp_link_sqrt_linkfun`, mu)
}

#' @keywords internal
cpp.link.sqrt.linkinv <- function(eta) {
    .Call(`_sgdGMF_cpp_link_sqrt_linkinv`, eta)
}

#' @keywords internal
cpp.link.sqrt.mueta <- function(eta) {
    .Call(`_sgdGMF_cpp_link_sqrt_mueta`, eta)
}

#' @keywords internal
cpp.get.chunk <- function(iter, n, size, randomize) {
    .Call(`_sgdGMF_cpp_get_chunk`, iter, n, size, randomize)
}

#' @keywords internal
cpp.get.chunks <- function(iters, n, size, randomize) {
    .Call(`_sgdGMF_cpp_get_chunks`, iters, n, size, randomize)
}

#' @keywords internal
cpp.get.next <- function(iter, n, rnd) {
    .Call(`_sgdGMF_cpp_get_next`, iter, n, rnd)
}

#' @keywords internal
cpp.make.link.family <- function(familyname, linkname) {
    invisible(.Call(`_sgdGMF_cpp_make_link_family`, familyname, linkname))
}

#' @keywords internal
cpp.get.data.bounds <- function(eps, ymin, ymax, familyname, linkname) {
    .Call(`_sgdGMF_cpp_get_data_bounds`, eps, ymin, ymax, familyname, linkname)
}

#' @keywords internal
cpp.get.uv.penalty <- function(pen, p, q, d) {
    .Call(`_sgdGMF_cpp_get_uv_penalty`, pen, p, q, d)
}

#' @keywords internal
cpp.get.uv.indices <- function(p, q, d) {
    .Call(`_sgdGMF_cpp_get_uv_indices`, p, q, d)
}

#' @keywords internal
cpp.sample.minibatch <- function(n, size, randomize) {
    .Call(`_sgdGMF_cpp_sample_minibatch`, n, size, randomize)
}

#' @keywords internal
cpp.select.minibatch <- function(iter, nchunks) {
    .Call(`_sgdGMF_cpp_select_minibatch`, iter, nchunks)
}

#' @keywords internal
cpp.utils.dabsmax <- function(u, v) {
    .Call(`_sgdGMF_cpp_dabsmax`, u, v)
}

#' @keywords internal
cpp.utils.vabsmax <- function(u, v) {
    .Call(`_sgdGMF_cpp_vabsmax`, u, v)
}

#' @keywords internal
cpp.utils.trim <- function(x, a, b) {
    .Call(`_sgdGMF_cpp_trim`, x, a, b)
}

#' @keywords internal
cpp.utils.xlogx <- function(x) {
    .Call(`_sgdGMF_cpp_xlogx`, x)
}

#' @keywords internal
cpp.utils.log1pexp <- function(x) {
    .Call(`_sgdGMF_cpp_log1pexp`, x)
}

#' @keywords internal
cpp.utils.log1mexp <- function(x) {
    .Call(`_sgdGMF_cpp_log1mexp`, x)
}

#' @keywords internal
cpp.utils.logit <- function(x) {
    .Call(`_sgdGMF_cpp_logit`, x)
}

#' @keywords internal
cpp.utils.expit <- function(x) {
    .Call(`_sgdGMF_cpp_expit`, x)
}

#' @keywords internal
cpp.utils.expit2 <- function(x) {
    .Call(`_sgdGMF_cpp_expit2`, x)
}

#' @keywords internal
cpp.utils.expitn <- function(x, n = 1) {
    .Call(`_sgdGMF_cpp_expitn`, x, n)
}

#' @keywords internal
cpp.utils.cloglog <- function(x) {
    .Call(`_sgdGMF_cpp_cloglog`, x)
}

#' @keywords internal
cpp.utils.cexpexp <- function(x) {
    .Call(`_sgdGMF_cpp_cexpexp`, x)
}

#' @keywords internal
cpp.utils.loglog <- function(x) {
    .Call(`_sgdGMF_cpp_loglog`, x)
}

#' @keywords internal
cpp.utils.expexp <- function(x) {
    .Call(`_sgdGMF_cpp_expexp`, x)
}

#' @keywords internal
cpp.utils.pdfn <- function(x) {
    .Call(`_sgdGMF_cpp_pdfn`, x)
}

#' @keywords internal
cpp.utils.cdfn <- function(x) {
    .Call(`_sgdGMF_cpp_cdfn`, x)
}

#' @keywords internal
cpp.utils.logpdfn <- function(x) {
    .Call(`_sgdGMF_cpp_logpdfn`, x)
}

#' @keywords internal
cpp.utils.logcdfn <- function(x) {
    .Call(`_sgdGMF_cpp_logcdfn`, x)
}

#' @keywords internal
cpp.utils.gamma <- function(x) {
    .Call(`_sgdGMF_cpp_gamma`, x)
}

#' @keywords internal
cpp.utils.loggamma <- function(x) {
    .Call(`_sgdGMF_cpp_loggamma`, x)
}

#' @keywords internal
cpp.utils.digamma <- function(x) {
    .Call(`_sgdGMF_cpp_digamma`, x)
}

#' @keywords internal
cpp.utils.trigamma <- function(x) {
    .Call(`_sgdGMF_cpp_trigamma`, x)
}

#' @keywords internal
cpp.utils.beta <- function(x, y) {
    .Call(`_sgdGMF_cpp_beta`, x, y)
}

#' @keywords internal
cpp.utils.logbeta <- function(x, y) {
    .Call(`_sgdGMF_cpp_logbeta`, x, y)
}

#' @keywords internal
cpp.utils.dibeta <- function(x, y) {
    .Call(`_sgdGMF_cpp_dibeta`, x, y)
}

#' @keywords internal
cpp.utils.tribeta <- function(x, y) {
    .Call(`_sgdGMF_cpp_tribeta`, x, y)
}

#' @keywords internal
cpp.utils.hinge <- function(x) {
    .Call(`_sgdGMF_cpp_hinge`, x)
}

#' @keywords internal
cpp.utils.dirac <- function(x, a = 0) {
    .Call(`_sgdGMF_cpp_dirac`, x, a)
}

#' @keywords internal
cpp.utils.step <- function(x, a = 0, lower = TRUE) {
    .Call(`_sgdGMF_cpp_step`, x, a, lower)
}

#' @keywords internal
cpp.utils.vech <- function(A) {
    .Call(`_sgdGMF_cpp_vech`, A)
}

